// ============================================
// Wiki Blog - Main Application
// ============================================

import { CONFIG } from './config.js';

// Wait for libraries to load
let librariesReady = false;
const checkLibraries = () => {
    return typeof showdown !== 'undefined' &&
           typeof FlexSearch !== 'undefined' &&
           typeof cytoscape !== 'undefined';
};

// ============================================
// State
// ============================================
const state = {
    files: [],
    docs: new Map(),
    graph: new Map(),
    currentDoc: null,
    searchIndex: null,
    cy: null
};

// ============================================
// DOM Elements
// ============================================
const $ = {
    commandInput: document.getElementById('command-input'),
    commandResults: document.getElementById('command-results'),
    fileTree: document.getElementById('file-tree'),
    placeholder: document.getElementById('placeholder'),
    document: document.getElementById('document'),
    docTitle: document.getElementById('doc-title'),
    docContent: document.getElementById('doc-content'),
    docTags: document.getElementById('doc-tags'),
    breadcrumbs: document.getElementById('breadcrumbs'),
    backlinks: document.getElementById('backlinks'),
    toc: document.getElementById('toc'),
    status: document.getElementById('status'),
    btnTheme: document.getElementById('btn-theme'),
    btnGraph: document.getElementById('btn-graph'),
    graphModal: document.getElementById('graph-modal'),
    graphContainer: document.getElementById('graph-container'),
    graphSearch: document.getElementById('graph-search'),
    closeGraph: document.getElementById('close-graph'),
    homeLink: document.getElementById('home-link')
};

// ============================================
// Utilities
// ============================================
function updateStatus(msg) {
    if ($.status) $.status.textContent = msg;
}

// ============================================
// GitHub API
// ============================================
async function fetchGitHubTree() {
    const url = `https://api.github.com/repos/${CONFIG.githubUser}/${CONFIG.githubRepo}/git/trees/${CONFIG.githubBranch}?recursive=1`;
    updateStatus('Fetching from GitHub...');

    try {
        const res = await fetch(url);
        if (!res.ok) {
            throw new Error(`GitHub API error: ${res.status} ${res.statusText}`);
        }
        const data = await res.json();

        state.files = data.tree.filter(node =>
            node.type === 'blob' &&
            (node.path.endsWith('.md') || node.path.endsWith('.mdx'))
        );

        updateStatus(`Found ${state.files.length} documents`);
        return state.files;
    } catch (err) {
        console.error('GitHub fetch error:', err);
        updateStatus(`Error: ${err.message}`);
        throw err;
    }
}

async function fetchFileContent(path) {
    const url = `https://raw.githubusercontent.com/${CONFIG.githubUser}/${CONFIG.githubRepo}/${CONFIG.githubBranch}/${path}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Failed to fetch ${path}`);
    return await res.text();
}

// ============================================
// Document Processing
// ============================================
function parseFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---/);
    if (!match) return { frontmatter: {}, content };

    const yaml = match[1];
    const fm = {};

    yaml.split('\n').forEach(line => {
        const colonIdx = line.indexOf(':');
        if (colonIdx === -1) return;

        const key = line.slice(0, colonIdx).trim();
        let value = line.slice(colonIdx + 1).trim();

        if (value.startsWith('[') && value.endsWith(']')) {
            fm[key] = value.slice(1, -1)
                .split(',')
                .map(s => s.trim().replace(/['"]/g, ''));
        } else {
            fm[key] = value.replace(/['"]/g, '');
        }
    });

    return {
        frontmatter: fm,
        content: content.slice(match[0].length).trim()
    };
}

function extractTitle(path, frontmatter, content) {
    // Always use filename as title for consistency
    const filename = path.split('/').pop().replace(/\.mdx?$/, '');
    return frontmatter.title || filename;
}

function extractLinks(content) {
    const links = new Set();
    const wikiRegex = /\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/g;
    let match;
    while ((match = wikiRegex.exec(content)) !== null) {
        links.add(match[1].trim());
    }
    const mdRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
    while ((match = mdRegex.exec(content)) !== null) {
        const href = match[2];
        if (!href.startsWith('http') && !href.startsWith('#') && !href.startsWith('mailto:')) {
            links.add(href);
        }
    }
    return Array.from(links);
}

async function indexDocuments() {
    updateStatus('Indexing documents...');

    for (const file of state.files) {
        const content = await fetchFileContent(file.path);
        const { frontmatter, content: bodyContent } = parseFrontmatter(content);

        const doc = {
            path: file.path,
            title: extractTitle(file.path, frontmatter, bodyContent),
            content: bodyContent,
            fullContent: content,
            tags: frontmatter.tags || [],
            aliases: frontmatter.aliases || [],
            description: frontmatter.description || '',
            links: extractLinks(content)
        };

        state.docs.set(file.path, doc);
    }

    buildGraph();
    buildSearchIndex();
    updateStatus('Ready');
}

// ============================================
// Graph
// ============================================
function resolveWikiLink(target) {
    const targetLower = target.toLowerCase().trim();

    for (const [path, doc] of state.docs) {
        if (path.toLowerCase() === targetLower ||
            path.toLowerCase().endsWith(`/${targetLower}.md`) ||
            path.toLowerCase().endsWith(`/${targetLower}.mdx`)) {
            return path;
        }
    }

    for (const [path, doc] of state.docs) {
        if (doc.title.toLowerCase() === targetLower) return path;
        if (doc.aliases.some(a => a.toLowerCase() === targetLower)) return path;
    }

    return null;
}

function buildGraph() {
    state.graph.clear();

    for (const path of state.docs.keys()) {
        state.graph.set(path, { out: new Set(), in: new Set() });
    }

    for (const [path, doc] of state.docs) {
        for (const link of doc.links) {
            const targetPath = resolveWikiLink(link);
            if (targetPath && state.graph.has(targetPath)) {
                state.graph.get(path).out.add(targetPath);
                state.graph.get(targetPath).in.add(path);
            }
        }
    }
}

// ============================================
// Search
// ============================================
function buildSearchIndex() {
    state.searchIndex = new FlexSearch.Document({
        document: {
            id: 'path',
            index: ['title', 'content', 'tags'],
            store: ['title', 'path']
        },
        tokenize: 'forward'
    });

    for (const [path, doc] of state.docs) {
        state.searchIndex.add({
            path,
            title: doc.title,
            content: doc.content,
            tags: doc.tags.join(' ')
        });
    }
}

async function search(query) {
    if (!state.searchIndex || !query) return [];
    const results = await state.searchIndex.search(query, { enrich: true, limit: 20 });
    const unique = new Map();
    for (const fieldResult of results) {
        for (const item of fieldResult.result) {
            if (!unique.has(item.id)) {
                unique.set(item.id, item.doc);
            }
        }
    }
    return Array.from(unique.values());
}

// ============================================
// Command Palette
// ============================================
const commands = [
    { id: 'home', icon: '🏠', label: 'Go Home', action: () => showHome() },
    { id: 'graph', icon: '🕸️', label: 'Show Graph', action: () => openGraph() },
    { id: 'theme', icon: '🌓', label: 'Toggle Theme', action: () => toggleTheme() },
    { id: 'random', icon: '🎲', label: 'Random Document', action: () => openRandomDoc() }
];

function handleCommandInput(event) {
    const query = event.target.value;
    if (!query) {
        $.commandResults.style.display = 'none';
        return;
    }

    if (query.startsWith('>')) {
        const searchTerm = query.slice(1).trim().toLowerCase();
        const matches = commands.filter(cmd =>
            cmd.label.toLowerCase().includes(searchTerm)
        );
        renderCommandResults(matches, true);
    } else {
        search(query).then(results => renderCommandResults(results, false));
    }
}

function renderCommandResults(results, isCommand) {
    if (results.length === 0) {
        $.commandResults.style.display = 'none';
        return;
    }

    $.commandResults.style.display = 'block';
    $.commandResults.innerHTML = results.map((item, idx) => {
        if (isCommand) {
            return `
                <div class="command-item" data-idx="${idx}" data-command="${item.id}">
                    <span class="cmd-icon">${item.icon}</span>
                    <span class="cmd-label">${item.label}</span>
                </div>
            `;
        } else {
            return `
                <div class="command-item" data-path="${item.path}">
                    <span class="cmd-icon">📄</span>
                    <span class="cmd-label">${item.title}</span>
                    <span class="cmd-path">${item.path}</span>
                </div>
            `;
        }
    }).join('');

    $.commandResults.querySelectorAll('.command-item').forEach((el) => {
        el.addEventListener('click', () => {
            if (isCommand) {
                const cmdId = el.dataset.command;
                const cmd = commands.find(c => c.id === cmdId);
                if (cmd) cmd.action();
            } else {
                openDocument(el.dataset.path);
            }
            $.commandInput.value = '';
            $.commandResults.style.display = 'none';
        });
    });
}

// ============================================
// File Tree
// ============================================
function renderFileTree() {
    const tree = {};

    for (const [path, doc] of state.docs) {
        const parts = path.split('/');
        let current = tree;

        for (let i = 0; i < parts.length - 1; i++) {
            const folder = parts[i];
            if (!current[folder]) current[folder] = {};
            current = current[folder];
        }

        current['__file__' + path] = doc;
    }

    $.fileTree.innerHTML = renderTreeNode(tree, 0);

    $.fileTree.querySelectorAll('[data-path]').forEach(el => {
        el.addEventListener('click', (e) => {
            e.stopPropagation();
            openDocument(el.dataset.path);
        });
    });

    // Highlight current document
    updateActiveFileInList();
}

function renderTreeNode(node, level) {
    let html = '';
    const indent = level * 16;

    const folders = Object.keys(node).filter(k => !k.startsWith('__file__')).sort();
    for (const folder of folders) {
        html += `
            <details class="folder" open>
                <summary style="padding-left: ${indent}px">
                    <span class="folder-icon">📁</span>
                    <span class="folder-name">${folder}</span>
                </summary>
                <div class="folder-content">
                    ${renderTreeNode(node[folder], level + 1)}
                </div>
            </details>
        `;
    }

    const files = Object.keys(node).filter(k => k.startsWith('__file__')).sort();
    for (const fileKey of files) {
        const doc = node[fileKey];
        html += `
            <div class="file-item" data-path="${doc.path}" style="padding-left: ${indent + 16}px">
                <span class="file-icon">📄</span>
                <span class="file-name">${doc.title}</span>
            </div>
        `;
    }

    return html;
}

// ============================================
// File List Highlighting
// ============================================
function updateActiveFileInList() {
    $.fileTree.querySelectorAll('.file-item').forEach(el => {
        el.classList.remove('active');
        if (el.dataset.path === state.currentDoc) {
            el.classList.add('active');
        }
    });
}

// ============================================
// Document Rendering
// ============================================
async function openDocument(path) {
    const doc = state.docs.get(path);
    if (!doc) return;

    state.currentDoc = path;
    $.placeholder.style.display = 'none';
    $.document.style.display = 'block';

    // Update active file highlight
    updateActiveFileInList();

    // Initialize converter with wiki link extension
    const converter = new showdown.Converter({
        ghCompatibleHeaderId: true,
        simpleLineBreaks: true,
        strikethrough: true,
        tables: true,
        tasklists: true
    });

    showdown.extension('wikilinks', {
        type: 'lang',
        regex: /\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g,
        replace: (match, target, display) => {
            const text = display || target;
            const resolved = resolveWikiLink(target);
            if (resolved) {
                return `<a href="#${resolved}" class="wiki-link">${text}</a>`;
            }
            return `<span class="unresolved-link">${text}</span>`;
        }
    });

    converter.addExtension('wikilinks');

    $.docTitle.textContent = doc.title;
    $.docContent.innerHTML = converter.makeHtml(doc.content);

    if (doc.tags.length > 0) {
        $.docTags.innerHTML = doc.tags.map(tag =>
            `<span class="tag">${tag}</span>`
        ).join('');
    } else {
        $.docTags.innerHTML = '';
    }

    renderBreadcrumbs(path);
    renderBacklinks(path);
    renderTOC();

    if (typeof Prism !== 'undefined') {
        Prism.highlightAllUnder($.docContent);
    }

    window.location.hash = path;
    updateStatus(`Viewing: ${doc.title}`);
}

function renderBreadcrumbs(path) {
    const parts = path.split('/');
    let html = '<a href="#" class="crumb">Home</a>';

    let current = '';
    for (let i = 0; i < parts.length; i++) {
        current += (current ? '/' : '') + parts[i];
        const isLast = i === parts.length - 1;

        if (isLast) {
            html += ` <span class="sep">/</span> <span class="crumb current">${parts[i]}</span>`;
        } else {
            html += ` <span class="sep">/</span> <span class="crumb">${parts[i]}</span>`;
        }
    }

    $.breadcrumbs.innerHTML = html;
}

function renderBacklinks(path) {
    const node = state.graph.get(path);
    if (!node || node.in.size === 0) {
        $.backlinks.innerHTML = '';
        return;
    }

    let html = '<h3>Backlinks</h3><ul class="backlinks-list">';
    for (const inPath of node.in) {
        const doc = state.docs.get(inPath);
        html += `<li><a href="#${inPath}" class="backlink" data-doc-path="${inPath}">${doc.title}</a></li>`;
    }
    html += '</ul>';
    $.backlinks.innerHTML = html;

    // Add click handlers for backlinks
    $.backlinks.querySelectorAll('a[data-doc-path]').forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const docPath = link.getAttribute('data-doc-path');
            openDocument(docPath);
        });
    });
}

function renderTOC() {
    const headings = $.docContent.querySelectorAll('h1, h2, h3, h4');
    if (headings.length === 0) {
        $.toc.innerHTML = '';
        return;
    }

    let html = '<ul class="toc-list">';
    headings.forEach(h => {
        const level = parseInt(h.tagName[1]);
        const text = h.textContent;
        const id = h.id || text.toLowerCase().replace(/[^\w]+/g, '-');
        h.id = id;

        html += `<li class="toc-item toc-level-${level}">
            <a href="#${id}" data-scroll-to="${id}">${text}</a>
        </li>`;
    });
    html += '</ul>';
    $.toc.innerHTML = html;

    // Add click handlers for TOC links
    $.toc.querySelectorAll('a[data-scroll-to]').forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const targetId = link.getAttribute('data-scroll-to');
            const targetEl = document.getElementById(targetId);
            if (targetEl) {
                targetEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        });
    });
}

function showHome() {
    state.currentDoc = null;
    $.document.style.display = 'none';
    $.placeholder.style.display = 'flex';
    window.location.hash = '';
    updateStatus('Home');
}

function openRandomDoc() {
    const paths = Array.from(state.docs.keys());
    const randomPath = paths[Math.floor(Math.random() * paths.length)];
    openDocument(randomPath);
}

// ============================================
// Graph Visualization
// ============================================
function openGraph() {
    $.graphModal.showModal();
    renderGraph();
}

function renderGraph() {
    if (state.cy) {
        state.cy.destroy();
        state.cy = null;
    }

    const elements = [];

    for (const [path, doc] of state.docs) {
        elements.push({
            data: { id: path, label: doc.title }
        });
    }

    for (const [path, node] of state.graph) {
        for (const target of node.out) {
            elements.push({
                data: { source: path, target }
            });
        }
    }

    // Register layout if needed
    if (typeof cytoscape !== 'undefined' && typeof cytoscapeCoseBilkent !== 'undefined') {
        cytoscape.use(cytoscapeCoseBilkent);
    }

    state.cy = cytoscape({
        container: $.graphContainer,
        elements,
        style: [
            {
                selector: 'node',
                style: {
                    'label': 'data(label)',
                    'font-size': 12,
                    'background-color': '#5aa2ff',
                    'color': '#fff',
                    'text-outline-color': '#000',
                    'text-outline-width': 2
                }
            },
            {
                selector: 'edge',
                style: {
                    'width': 2,
                    'line-color': '#666',
                    'target-arrow-color': '#666',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier'
                }
            },
            {
                selector: '.highlight',
                style: {
                    'background-color': '#ff6b6b',
                    'line-color': '#ff6b6b',
                    'target-arrow-color': '#ff6b6b'
                }
            }
        ],
        layout: {
            name: 'circle',
            padding: 30
        }
    });

    state.cy.on('tap', 'node', (evt) => {
        const path = evt.target.id();
        openDocument(path);
        $.graphModal.close();
    });

    if (state.currentDoc) {
        state.cy.$(`#${CSS.escape(state.currentDoc)}`).addClass('highlight');
    }
}

document.querySelectorAll('.layout-buttons button').forEach(btn => {
    btn.addEventListener('click', () => {
        if (!state.cy) return;
        const layout = btn.dataset.layout;
        state.cy.layout({ name: layout, animate: true }).run();
        document.querySelectorAll('.layout-buttons button').forEach(b =>
            b.classList.remove('active')
        );
        btn.classList.add('active');
    });
});

$.graphSearch.addEventListener('input', (e) => {
    if (!state.cy) return;
    const query = e.target.value.toLowerCase();

    if (!query) {
        state.cy.elements().removeClass('filtered');
        return;
    }

    state.cy.nodes().forEach(node => {
        const label = node.data('label').toLowerCase();
        if (label.includes(query)) {
            node.removeClass('filtered');
        } else {
            node.addClass('filtered');
        }
    });
});

// ============================================
// Theme
// ============================================
function toggleTheme() {
    const html = document.documentElement;
    const current = html.getAttribute('data-theme');
    const next = current === 'dark' ? 'light' : 'dark';
    html.setAttribute('data-theme', next);
    localStorage.setItem('theme', next);
}

function initTheme() {
    const saved = localStorage.getItem('theme') || 'dark';
    document.documentElement.setAttribute('data-theme', saved);
}

// ============================================
// Event Listeners
// ============================================
$.commandInput.addEventListener('input', handleCommandInput);
$.commandInput.addEventListener('blur', () => {
    setTimeout(() => $.commandResults.style.display = 'none', 200);
});

$.btnTheme.addEventListener('click', toggleTheme);
$.btnGraph.addEventListener('click', openGraph);
$.closeGraph.addEventListener('click', () => $.graphModal.close());
$.homeLink.addEventListener('click', (e) => {
    e.preventDefault();
    showHome();
});

window.addEventListener('hashchange', () => {
    const hash = window.location.hash.slice(1);
    if (hash && state.docs.has(hash)) {
        openDocument(hash);
    } else {
        showHome();
    }
});

// ============================================
// Initialization
// ============================================
async function init() {
    console.log('Initializing Wiki Blog...');

    // Wait for libraries
    if (!checkLibraries()) {
        console.log('Waiting for libraries to load...');
        setTimeout(init, 100);
        return;
    }

    initTheme();

    try {
        await fetchGitHubTree();
        await indexDocuments();
        renderFileTree();

        const hash = window.location.hash.slice(1);
        if (hash && state.docs.has(hash)) {
            openDocument(hash);
        }

        console.log('Initialized successfully!');
    } catch (err) {
        console.error('Initialization failed:', err);
        updateStatus(`Error: ${err.message}`);
    }
}

// Start
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
} else {
    init();
}
